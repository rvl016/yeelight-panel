// AUTO GENERATED FILE, DO NOT EDIT.
// Generated by `flutter_rust_bridge`@ 1.65.1.
// ignore_for_file: non_constant_identifier_names, unused_element, duplicate_ignore, directives_ordering, curly_braces_in_flow_control_structures, unnecessary_lambdas, slash_for_doc_comments, prefer_const_literals_to_create_immutables, implicit_dynamic_list_literal, duplicate_import, unused_import, unnecessary_import, prefer_single_quotes, prefer_const_constructors, use_super_parameters, always_use_package_imports, annotate_overrides, invalid_use_of_protected_member, constant_identifier_names, invalid_use_of_internal_member, prefer_is_empty

import 'dart:convert';
import 'dart:async';
import 'package:meta/meta.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'package:collection/collection.dart';

import 'data/model/base.dart';

part 'bridge_definitions.freezed.dart';

abstract class Native {
  Future<Platform> platform({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kPlatformConstMeta;

  Future<bool> rustReleaseMode({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kRustReleaseModeConstMeta;

  Future<void> initApp({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kInitAppConstMeta;

  Future<DeviceDetectResultInterface> detectNewDevice(
      {required String deviceName,
      required ConnectionConfigInterface connection,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kDetectNewDeviceConstMeta;

  Future<List<DeviceDataInterface>> getStoredDevices({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetStoredDevicesConstMeta;

  Future<void> removeDevice({required String deviceId, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kRemoveDeviceConstMeta;

  Future<DeviceStateUpdateResult> setBrightness(
      {required String deviceId, required double brightness, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSetBrightnessConstMeta;

  Future<DeviceStateUpdateResult> setRgb(
      {required String deviceId, required RGBInterface rgb, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSetRgbConstMeta;

  Future<DeviceStateUpdateResult> setHsv(
      {required String deviceId, required HSVInterface hsv, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSetHsvConstMeta;

  Future<DeviceStateUpdateResult> setCt(
      {required String deviceId, required CTInterface ct, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSetCtConstMeta;

  Future<DeviceStateUpdateResult> setColorMode(
      {required String deviceId, required ColorMode colorMode, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSetColorModeConstMeta;

  Future<List<DeviceInterface>> getDevicesForUsing({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetDevicesForUsingConstMeta;

  Future<DeviceStateInterface> getDeviceState(
      {required String deviceId, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetDeviceStateConstMeta;

  Future<DeviceStateInterface> syncDeviceState(
      {required String deviceId, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSyncDeviceStateConstMeta;

  Future<List<ProfileInterface>> getProfiles({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetProfilesConstMeta;
}

class AnimationStateInteface {
  const AnimationStateInteface();
}

@freezed
class ColorInterface with _$ColorInterface {
  const factory ColorInterface.none() = ColorInterface_None;
  const factory ColorInterface.hsv(
    HSVInterface field0,
  ) = ColorInterface_HSV;
  const factory ColorInterface.rgb(
    RGBInterface field0,
  ) = ColorInterface_RGB;
  const factory ColorInterface.ct(
    CTInterface field0,
  ) = ColorInterface_CT;
}

enum ColorMode {
  None,
  HSV,
  RGB,
  CT,
}

class ColorStateInterface {
  final double brightness;
  final ColorInterface color;
  ColorStateInterface({
    required this.brightness,
    required this.color,
  });
}

class ConnectionConfigInterface {
  final IPv4ConnectionInteface ipV4;
  ConnectionConfigInterface({
    required this.ipV4,
  });
}

class CTInterface {
  final int temperature;
  CTInterface({
    required this.temperature,
  });
}

class DeviceActionResultMetaInterface {
  final bool hadSuccess;
  final DeviceResultCode code;
  final String message;
  DeviceActionResultMetaInterface({
    required this.hadSuccess,
    required this.code,
    required this.message,
  });
}

enum DeviceCommandCapability {
  SwitchPower,
  SetBrightness,
  SetRGB,
  SetHSV,
  SetCT,
  SetAnimation,
  SetDirectMode,
}

class DeviceDataInterface implements Data {
  final String id;
  final String name;
  final DeviceType deviceType;
  final DeviceImpl deviceImpl;
  final List<Wrapper> capabilities;
  DeviceDataInterface({
    required this.id,
    required this.name,
    required this.deviceType,
    required this.deviceImpl,
    required this.capabilities,
  });
}

class DeviceDetectErrorItemInterface {
  final DeviceImpl field0;
  final String field1;
  DeviceDetectErrorItemInterface({
    required this.field0,
    required this.field1,
  });
}

@freezed
class DeviceDetectResultInterface with _$DeviceDetectResultInterface {
  const factory DeviceDetectResultInterface.ok(
    DeviceDataInterface field0,
  ) = DeviceDetectResultInterface_Ok;
  const factory DeviceDetectResultInterface.error(
    List<DeviceDetectErrorItemInterface> field0,
  ) = DeviceDetectResultInterface_Error;
}

enum DeviceImpl {
  None,
  Yeelight,
}

class DeviceInterface implements Data {
  final String id;
  final DeviceDataInterface metadata;
  final DeviceStateInterface? state;
  DeviceInterface({
    required this.id,
    required this.metadata,
    this.state,
  });
}

enum DeviceResultCode {
  Ok,
  ConnectionError,
  DeviceError,
  RequestError,
}

class DeviceStateInterface {
  final ConnectionConfigInterface config;
  final RunningStateInterface runningState;
  DeviceStateInterface({
    required this.config,
    required this.runningState,
  });
}

@freezed
class DeviceStateUpdateResult with _$DeviceStateUpdateResult {
  const factory DeviceStateUpdateResult.ok(
    DeviceStateInterface field0,
  ) = DeviceStateUpdateResult_Ok;
  const factory DeviceStateUpdateResult.err(
    DeviceActionResultMetaInterface field0,
  ) = DeviceStateUpdateResult_Err;
}

enum DeviceType {
  Bulb,
}

class DirectModeStateInterface {
  final ConnectionConfigInterface connectionAddr;
  DirectModeStateInterface({
    required this.connectionAddr,
  });
}

class HSVInterface {
  final double hue;
  final double saturation;
  HSVInterface({
    required this.hue,
    required this.saturation,
  });
}

class IPv4ConnectionInteface {
  final U8Array4 ip;
  final int port;
  IPv4ConnectionInteface({
    required this.ip,
    required this.port,
  });
}

enum Platform {
  Unknown,
  Android,
  Ios,
  Windows,
  Unix,
  MacIntel,
  MacApple,
  Wasm,
}

@freezed
class ProfileDataInterface with _$ProfileDataInterface {
  const factory ProfileDataInterface.none() = ProfileDataInterface_None;
  const factory ProfileDataInterface.single(
    ProfileSingleInterface field0,
  ) = ProfileDataInterface_Single;
  const factory ProfileDataInterface.multiple(
    ProfileMultipleInterface field0,
  ) = ProfileDataInterface_Multiple;
}

class ProfileInterface implements Data {
  final String id;
  final String name;
  final ProfileDataInterface data;
  ProfileInterface({
    required this.id,
    required this.name,
    required this.data,
  });
}

class ProfileMultipleInterface {
  final List<DeviceInterface> devices;
  final DeviceStateInterface state;
  ProfileMultipleInterface({
    required this.devices,
    required this.state,
  });
}

class ProfileSingleInterface {
  final DeviceInterface device;
  final DeviceStateInterface state;
  ProfileSingleInterface({
    required this.device,
    required this.state,
  });
}

class RGBInterface {
  final U8Array3 rgb;
  RGBInterface({
    required this.rgb,
  });
}

@freezed
class RunningStateInterface with _$RunningStateInterface {
  const factory RunningStateInterface.none() = RunningStateInterface_None;
  const factory RunningStateInterface.color(
    ColorStateInterface field0,
  ) = RunningStateInterface_Color;
  const factory RunningStateInterface.animation(
    AnimationStateInteface field0,
  ) = RunningStateInterface_Animation;
  const factory RunningStateInterface.directMode(
    DirectModeStateInterface field0,
  ) = RunningStateInterface_DirectMode;
}

class U8Array3 extends NonGrowableListView<int> {
  static const arraySize = 3;
  U8Array3(Uint8List inner)
      : assert(inner.length == arraySize),
        super(inner);
  U8Array3.unchecked(Uint8List inner) : super(inner);
  U8Array3.init() : super(Uint8List(arraySize));
}

class U8Array4 extends NonGrowableListView<int> {
  static const arraySize = 4;
  U8Array4(Uint8List inner)
      : assert(inner.length == arraySize),
        super(inner);
  U8Array4.unchecked(Uint8List inner) : super(inner);
  U8Array4.init() : super(Uint8List(arraySize));
}

class Wrapper {
  final DeviceCommandCapability data;
  Wrapper({
    required this.data,
  });
}
