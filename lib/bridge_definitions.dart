// AUTO GENERATED FILE, DO NOT EDIT.
// Generated by `flutter_rust_bridge`@ 1.65.1.
// ignore_for_file: non_constant_identifier_names, unused_element, duplicate_ignore, directives_ordering, curly_braces_in_flow_control_structures, unnecessary_lambdas, slash_for_doc_comments, prefer_const_literals_to_create_immutables, implicit_dynamic_list_literal, duplicate_import, unused_import, unnecessary_import, prefer_single_quotes, prefer_const_constructors, use_super_parameters, always_use_package_imports, annotate_overrides, invalid_use_of_protected_member, constant_identifier_names, invalid_use_of_internal_member, prefer_is_empty

import 'dart:convert';
import 'dart:async';
import 'package:meta/meta.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'package:collection/collection.dart';

import 'data/model/base.dart';

part 'bridge_definitions.freezed.dart';

abstract class Native {
  Future<Platform> platform({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kPlatformConstMeta;

  Future<bool> rustReleaseMode({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kRustReleaseModeConstMeta;

  Future<void> initApp({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kInitAppConstMeta;

  Future<List<DeviceDataInterface>> getStoredDevices({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetStoredDevicesConstMeta;

  Future<DeviceDetectResult> detectNewDevice(
      {required String deviceName,
      required ConnectionConfigInterface connection,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kDetectNewDeviceConstMeta;

  Future<List<DeviceInterface>> getDevicesForUsing({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetDevicesForUsingConstMeta;

  Future<DeviceStateInterface?> getDeviceState(
      {required String deviceId, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetDeviceStateConstMeta;
}

class AnimationStateInteface {
  const AnimationStateInteface();
}

@freezed
class ColorInterface with _$ColorInterface {
  const factory ColorInterface.none() = ColorInterface_None;
  const factory ColorInterface.hsv(
    HSVInterface field0,
  ) = ColorInterface_HSV;
  const factory ColorInterface.rgb(
    RGBInterface field0,
  ) = ColorInterface_RGB;
  const factory ColorInterface.ct(
    CTInterface field0,
  ) = ColorInterface_CT;
}

class ColorStateInteface {
  final int brightness;
  final ColorInterface color;
  ColorStateInteface({
    required this.brightness,
    required this.color,
  });
}

class ConnectionConfigInterface {
  final IPv4ConnectionInteface ipV4;
  ConnectionConfigInterface({
    required this.ipV4,
  });
}

class CTInterface {
  final int temperature;
  CTInterface({
    required this.temperature,
  });
}

enum DeviceCommandCapability {
  SwitchPower,
  SetColor,
  SetAnimation,
  SetDirectMode,
}

class DeviceDataInterface implements Data {
  final String id;
  final String name;
  final DeviceType deviceType;
  final DeviceImpl deviceImpl;
  final List<Wrapper> capabilities;
  DeviceDataInterface({
    required this.id,
    required this.name,
    required this.deviceType,
    required this.deviceImpl,
    required this.capabilities,
  });
}

class DeviceDetectErrorItem {
  final DeviceImpl field0;
  final String field1;
  DeviceDetectErrorItem({
    required this.field0,
    required this.field1,
  });
}

@freezed
class DeviceDetectResult with _$DeviceDetectResult {
  const factory DeviceDetectResult.ok(
    DeviceDataInterface field0,
  ) = DeviceDetectResult_Ok;
  const factory DeviceDetectResult.error(
    List<DeviceDetectErrorItem> field0,
  ) = DeviceDetectResult_Error;
}

enum DeviceImpl {
  None,
  Yeelight,
}

class DeviceInterface implements Data {
  final String id;
  final DeviceDataInterface metadata;
  DeviceInterface({
    required this.id,
    required this.metadata,
  });
}

class DeviceStateInterface {
  final ConnectionConfigInterface config;
  final RunningStateInterface runningState;
  DeviceStateInterface({
    required this.config,
    required this.runningState,
  });
}

enum DeviceType {
  Bulb,
}

class DirectModeStateInterface {
  final ConnectionConfigInterface connectionAddr;
  DirectModeStateInterface({
    required this.connectionAddr,
  });
}

class HSVInterface {
  final int hue;
  final int saturation;
  HSVInterface({
    required this.hue,
    required this.saturation,
  });
}

class IPv4ConnectionInteface {
  final U8Array4 ip;
  final int port;
  IPv4ConnectionInteface({
    required this.ip,
    required this.port,
  });
}

enum Platform {
  Unknown,
  Android,
  Ios,
  Windows,
  Unix,
  MacIntel,
  MacApple,
  Wasm,
}

class RGBInterface {
  final U8Array3 rgb;
  RGBInterface({
    required this.rgb,
  });
}

@freezed
class RunningStateInterface with _$RunningStateInterface {
  const factory RunningStateInterface.none() = RunningStateInterface_None;
  const factory RunningStateInterface.color(
    ColorStateInteface field0,
  ) = RunningStateInterface_Color;
  const factory RunningStateInterface.animation(
    AnimationStateInteface field0,
  ) = RunningStateInterface_Animation;
  const factory RunningStateInterface.directMode(
    DirectModeStateInterface field0,
  ) = RunningStateInterface_DirectMode;
}

class U8Array3 extends NonGrowableListView<int> {
  static const arraySize = 3;
  U8Array3(Uint8List inner)
      : assert(inner.length == arraySize),
        super(inner);
  U8Array3.unchecked(Uint8List inner) : super(inner);
  U8Array3.init() : super(Uint8List(arraySize));
}

class U8Array4 extends NonGrowableListView<int> {
  static const arraySize = 4;
  U8Array4(Uint8List inner)
      : assert(inner.length == arraySize),
        super(inner);
  U8Array4.unchecked(Uint8List inner) : super(inner);
  U8Array4.init() : super(Uint8List(arraySize));
}

class Wrapper {
  final DeviceCommandCapability data;
  Wrapper({
    required this.data,
  });
}
